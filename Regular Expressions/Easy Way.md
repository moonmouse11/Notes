# [Easy Way](https://github.com/ziishaned/learn-regex/tree/master)
***
## Basic
**Регулярное выражение** - это шаблон, сопоставляемый с искомой строкой слева направо. Термин «Регулярное выражение» сложно произносить каждый раз, поэтому, обычно, вы будете сталкиваться с сокращениями "регэкспы" или "регулярки". Регулярные выражения используются для замен текста внутри строк, валидации форм, извлечений подстрок по определенным шаблонам и множества других вещей.
***
## Example
![[Pasted image 20241221114416.png]]
Регулярное выражения выше может принимать строки `john_doe`,`jo-hn_doe` и `john12_as`. Оно не валидирует `Jo`, поскольку эта строка содержит заглавные буквы, а также она слишком короткая.
***
## Matching
В сущности, регулярное выражение - это просто набор символов, который мы используем для поиска в тексте. Например, регулярное выражение `the` состоит из буквы `t`, за которой следует буква `h`, за которой следует буква `e`.
```regex
"the" => The fat cat sat on the mat.
```
Регулярное выражение `123` соответствует строке `123`. Регулярное выражение сопоставляется с входной строкой, сравнивая каждый символ в регулярном выражении с каждым символом во входной строке по одному символу за другим. Регулярные выражения обычно чувствительны к регистру, поэтому регулярное выражение `The` не будет соответствовать строке `the`.
```regex
"The" => The fat cat sat on the mat.
```
***
## Meta Characters
Метасимволы это блоки, из которых строятся регулярные выражения. Метасимволы не означают что-то сами по себе, вместо этого они интерпретируются для распознавания специальных групп символов. Некоторые метасимволы имеют особые обозначения и пишутся в квадратных скобках. Существуют следующие метасимволы:

|                                          Метасимволы                                          | Описание                                                                                 |
| :-------------------------------------------------------------------------------------------: | ---------------------------------------------------------------------------------------- |
|                                               .                                               | Точка соответствует любому отдельному символу, кроме разрыва строки.                     |
|                                              [ ]                                              | Класс символов. Находить любые символы заключенные в квадратных скобках.                 |
|                                             [^ ]                                              | Отрицание класа символов. Находить любые символы не заключенные в квадратных скобках.    |
|                                               *                                               | Находить 0 или более повторений предыдущего символа.                                     |
|                                               +                                               | Находить 1 или более повторений предыдущего символа.                                     |
|                                               ?                                               | Сделать предыдущий символ необязательным.                                                |
|                                             {n,m}                                             | Скобки. Находить по крайней мере "n" но не более чем "m" повторений предыдущего символа. |
|                                             (xyz)                                             | Группа символов. Находить только символы xyz в указанном порядке.                        |
|                                              \|                                               | Чередование. Находить либо буквы до, либо буквы после символа.                           |
| \|Экранирование. Позволяет находить зарезервированные символы: `[ ] ( ) { } . * + ? ^ $ \ \|` |                                                                                          |
|                                               ^                                               | Обозначает начало пользовательского ввода.                                               |
|                                               $                                               | Обозначает конец пользовательского ввода.                                                |
### The Full Stop
Точка `.` это простейший пример метасимвола. Метасимвол `.` находит любой отдельный символ. Точка не будет находить символы перехода или перевода строки. Например, регулярное выражение `.ar` обозначает: любой символ, за которым следуют буквы `a` и `r`.
```regex
".ar" => The car parked in the garage.
```
### Character Sets
Точка `.` это простейший пример метасимвола. Метасимвол `.` находит любой отдельный символ. Точка не будет находить символы перехода или перевода строки. Например, регулярное выражение `.ar` обозначает: любой символ, за которым следуют буквы `a` и `r`.
```regex
".ar" => The car parked in the garage.
```
Точка внутри набора символов, однако, обозначает непосредственно точку, как символ. Регулярное выражение `ar[.]` обозначает строчную `a`, за которой следует `r`, за которой следует `.` (символ точки).
```regex
"ar[.]" => A garage is a good place to park a car.
```
#### Negated Character Sets
Знак вставки `^` обозначает начало строки, однако, когда вы вписываете его после открытия квадратных скобок, он отрицает набор символов. Например, регулярное выражение `[^c]ar` обозначает любой символ, кроме `c`, за которым следуют буквы `a` и `r`.
```regex
"[^c]ar" => The car parked in the garage.
```
### Repetitions
Символы `+`, `*` или `?` используются для обозначения того сколько раз появляется какой-либо подшаблон. Данные метасимволы могут вести себя по-разному, в зависимости от ситуации.
#### The Star
Символ `*` обозначает ноль или более повторений предыдущего совпадения. Регулярное выражение `a*` означает ноль или более повторений предыдущего строчного символа `a`. Если же символ появляется после набора или класса символов, он находит повторения всего набора символов. Например, регулярное выражение `[a-z]*` означает любое количество строчных букв в строке.
```regex
"[a-z]*" => The car parked in the garage #21.
```
Символы можно комбинировать, так, например, символ * может использоваться с метасимволом . для поиска одной строки с произвольным содержанием .*. Символ * может использоваться с символом пробела \s, чтобы находить строки с символами пробела. Например, выражение \s*cat\s* означает: ноль или более пробелов, за которыми следует слово cat, за которым следует ноль или более символов пробела.
```regex
"\s*cat\s*" => The fat cat sat on the concatenation.
```
#### The Plus
Символ `+` соответствует одному или более повторению предыдущего символа. Например, регулярное выражение `c.+t` означает строчную `c`, за которой следует по крайней мере один символ, следом за которым идёт символ `t`. Стоит уточнить, что в данном шаблоне, `t` является последним `t` в предложении.
```regex
"c.+t" => The fat cat sat on the mat.
```
#### The Question Mark
В регулярном выражении метасимвол `?` делает предыдущий символ необязательным. Этот символ соответствует нулю или одному экземпляру предыдущего символа. Например, регулярное выражение `[T]?he` означает необязательную заглавную букву `T`, за которой следуют символы `h` и `e`.
```regex
"[T]he" => The car is parked in the garage.

"[T]?he" => The car is parked in the garage.
```
### Braces
В фигурных скобках, которые также называются квантификаторами, указывается, сколько раз символ или группа символов могут повторяться. Например, регулярное выражение `[0-9]{2,3}` означает совпадение не менее 2 но не более 3 цифр в диапазоне от 0 до 9.
```regex
"[0-9]{2,3}" => The number was 9.9997 but we rounded it off to 10.0.
```
Уберём второй номер (цифру 3), тогда, регулярное выражение `[0-9]{2,}` будет означать совпадение 2 или более цифр. Если мы также удалим запятую, то регулярное выражение `[0-9]{3}` будет означать совпадение точно с 3 цифрами.
```regex
"[0-9]{2,}" => The number was 9.9997 but we rounded it off to 10.0.

"[0-9]{3}" => The number was 9.9997 but we rounded it off to 10.0.
```
### Capturing Groups
Скобочные группы это группы подшаблонов, которые написаны в круглых скобках `(...)`. Как мы уже говорили ранее в регулярном выражении, если мы поставим квантификатор после символа, он будет повторять предыдущий символ. Но если мы поставим квантификатор после скобочной группы, он будет искать всю группу. Например, регулярное выражение `(ab)*` соответствует нулю или более повторений символа "ab". Мы также можем использовать метасимвол чередования `|` внутри скобочной группы. Например, регулярное выражение `(c|g|p)ar` означает поиск одной из строчных букв `c`, `g` или `p`, за которыми следуют буквы `a` и `r`.
```regex
"(c|g|p)ar" => The car is parked in the garage.
```
Обратите внимание, что скобочные группы не только находят, но и захватывают символы для использования на родительском языке. Родительским языком может быть `Python`, `JavaScript` или практически любой язык, который реализует использование регулярных выражений как параметров функций.
#### Non-Capturing Groups
Бывает так, что группу определить нужно, а вот запоминать их содержимое в массиве не требуется. Подобный трюк осуществляется при помощи зарезервированной комбинации `?:` в круглых скобках `(...)`. Например, регулярное выражение `(?:c|g|p)ar` будет находить такие же шаблоны как и `(c|g|p)ar`, однако скобочная группа при этом создана не будет.
```regex
"(?:c|g|p)ar" => The car is parked in the garage.
```
Незапоминающиеся группы могут пригодиться, когда они используются в функциях поиска и замены, или в сочетании со скобочными группами, например, для предпросмотра при создании скобочной группы или другого вида выходных данных.
### Alternation
В регулярных выражениях, вертикальная черта `|` используется для определения альтернации (чередования). Альтернация по своей сути похожа на оператор ИЛИ между логическими выражениями. Может создаться впечатление, что чередование это то же самое, что и определение набора символов. Однако, большая разница между ними в том, что набор символов работает на уровне конкретных символов, в то время как альтернация работает на уровне выражений. Например, регулярное выражение `(T|t)he|car` объединяет два шаблона (заглавная `T` ИЛИ строчная `t`, с продолжением из `h` и `e`) и шаблон (строчная `c`, затем строчная `a`, за которой следует строчная `r`). Таким образом, в поиске будет участвовать любой из данных шаблонов, по аналогии с логической операцией ИЛИ в программировании и алгебре выражений.
```regex
"(T|t)he|car" => The car is parked in the garage.
```
### Escaping Special Characters
Обратный слэш `\` используется в регулярных выражениях для экранирования следующего символа. Это позволяет формировать шаблоны с поиском зарезервированных символов, таких как `{ } [ ] / \ + * . $ ^ | ?`. Для использования спецсимвола в шаблоне необходимо указать символ `\` перед ним.
Как упомянуто выше, символ `.` является зарезервированным и соответствует любому значению, кроме символа новой строки. Бывают ситуации, когда необходимо найти точку в предложении, для таких случаев применимо экранирование. Рассмотрим выражение `(f|c|m)at\.?`, что соответствует следующему шаблону: строчный символ `f`, `c` или `m`, за которым следует строчные буквы `a` и `t`, с опциональной `.` точкой в конце.
```regex
"(f|c|m)at\.?" => The fat cat sat on the mat.
```
### Anchors
Понятие якорей в регулярных выражениях используется для обозначения проверок, является ли соответствующий символ начальным или конечным символом входной строки. Якоря бывают двух типов: Первый тип - Каретка `^`, проверяет, является ли соответствующий символ начальным символом в тексте. Второй тип - Доллар `$`, проверяет, является ли соответствующий символ последним символом входной строки.
#### The Caret
Символ каретки `^` используется для проверки, является ли соответствующий символ первым символом входной строки. Если мы применяем следующее регулярное выражение `^a` (если a является начальным символом) для строки `abc`, совпадение будет соответствовать букве `a`. Если же мы используем регулярное выражение `^b` на той же строке, мы не получим совпадения, поскольку во входящей строке `abc` "b" не является первым символом. Рассмотрим другое регулярное выражение: `^(T|t)he`, обозначающее заглавную `T` или строчную `t` как первый символ, за которым следуют символы букв `h` и `e`. Cоответственно:
```regex
"(T|t)he" => The car is parked in the garage.

"^(T|t)he" => The car is parked in the garage.
```
#### The Dollar Sign
Символ доллара `$` используется для проверки, является ли соответствующий символ последним символом входной строки. Например, регулярное выражение `(at\.)$` последовательность из строчной `a`, строчной `t`, и точки `.`, ключевой момент в том, что благодаря доллару этот шаблон будет находить совпадения только в том случае, если будет наблюдаться в конце строки.
```regex
"(at\.)" => The fat cat. sat. on the mat.

"(at\.)$" => The fat cat. sat. on the mat.
```
***
## Shorthand Character Sets
Регулярные выражения предоставляют сокращения для часто используемых наборов символов, которые предлагают удобные сокращения для часто используемых регулярных выражений. Наборы сокращенных символов следующие:

| Сокращение | Описание                                                     |
| :--------: | ------------------------------------------------------------ |
|     .      | Любой символ кроме символа новой строки                      |
|     \w     | Поиск буквенно-цифрового диапазона символов: `[a-zA-Z0-9_]`  |
|     \W     | Поиск не буквенно-цифрового диапазона символов: `[^\w]`      |
|     \d     | Поиск цифр: `[0-9]`                                          |
|     \D     | Поиск всего, что не является цифрой: `[^\d]`                 |
|     \s     | Поиск пробелов и символов начала строки: `[\t\n\f\r\p{Z}]`   |
|     \S     | Поиск всего кроме пробелов и символов начала строки: `[^\s]` |
***
## Lookarounds
Опережающие и ретроспективные проверки (в английской литературе lookbehind, lookahead) это особый вид _**не запоминающих скобочных групп**_ (находящих совпадения, но не добавляющих в массив). Данные проверки используются когда мы знаем, что шаблон предшествует или сопровождается другим шаблоном. Например, мы хотим получить цену в долларах `$` из следующей входной строки `$4.44 and $10.88`. Для этого используем следующее регулярное выражение `(?<=\$)[0-9\.]*`, означающее получение всех дробных (с точкой `.`) цифр, которым предшествует знак доллара `$`. 

| Символ | Описание                              |
| :----: | ------------------------------------- |
|   ?=   | Положительное опережающее условие     |
|   ?!   | Отрицательное опережающее условие     |
|  ?<=   | Положительное ретроспективное условие |
|  ?<!   | Отрицательное ретроспективное условие |
#### Positive Lookahead
Положительное опережающее утверждение (assert) означает, что за первой частью выражения должно следовать опережающее выражение (lookahead expression). (по аналогии с условиями, if (..) then (..)). Возвращенное совпадение содержит только текст, который соответствует первой части выражения. Для определения положительного опережающего условия используются круглые скобки. В этих скобках используется знак вопроса со знаком равенства: `(?=...)`. Опережающее выражение, записывается в скобках после знака равенства. Рассмотрим пример регулярного выражения: `(T|t)he(?=\sfat)`, обозначающее опциональное наличие строчной `t` или заглавной `T`, следом буквы `h` и `e`. В скобках, мы определяем положительное опережающее условие, которое сообщает движку регулярных выражений информацию о том, что после шаблона `The` или `the` будет следовать слово `fat`.
```regex
"(T|t)he(?=\sfat)" => The fat cat sat on the mat.
```
#### Negative Lookahead
Отрицательное опережающее условие работает по обратному принципу: используется, когда нам нужно получить все совпадения из входной строки, за которыми НЕ следует определенный шаблон. Отрицательное опережающее условие определяется таким же образом, как и позитивное, с той лишь разницей, что вместо равенства `=` мы ставим восклицательный знак `!` (отрицание) например: `(?!...)`. Рассмотрим выражение `(T|t)he(?!\sfat)`, в котором мы находим все `The` или `the` слова из входной строки, за которыми не следует слово `fat`.
```regex
"(T|t)he(?!\sfat)" => The fat cat sat on the mat.
```
#### Positive Lookbehind
Положительное ретроспективное условие используется чтобы найти все совпадения, которым предшествует определенный шаблон. Условие определяется как `(?<=...)`. Например, выражение `(?<=(T|t)he\s)(fat|mat)` означает, найти все слова `fat` или `mat` из входной строки, которым предшествует слово `The` или `the`.
```regex
"(?<=(T|t)he\s)(fat|mat)" => The fat cat sat on the mat.
```
#### Negative Lookbehind
Отрицательное ретроспективное условие используется чтобы найти все совпадения, которым НЕ предшествует определенный шаблон. Условие определяется как `(?<!...)`. Например, выражение `(?<!(T|t)he\s)(cat)` означает найти все слова `cat` из входной строки, которым не предшествует определенный артикль `The` или `the`.
```regex
"(?<!(T|t)he\s)(cat)" => The cat sat on cat.
```
***
### Flags
Флаги, также называемые модификаторами, изменяют вывод регулярного выражения. Эти флаги могут быть использованы в любом порядке или комбинации, и являются неотъемлемой частью регулярных выражений.

| Флаг | Описание                                                  |
| :--: | --------------------------------------------------------- |
|  i   | Поиск без учета регистра                                  |
|  g   | Глобальный поиск: поиск шаблона во всем входном тексте    |
|  m   | Мультистроковый поиск: Якоря применяются к каждой строке. |
#### Case Insensitive
Модификатор `i` используется для поиска без учета регистра. Например, регулярное выражение `/The/gi` означает заглавную `T` следом строчные `h` и `e`. В конце регулярного выражения флаг `i`, указывающий движку регулярных выражений игнорировать регистр. Помимо `i`, для поиска шаблона во всем входном тексте, использован флаг `g`.
```regex
"The" => The fat cat sat on the mat.

"/The/gi" => The fat cat sat on the mat.
```
#### Global Search
Модификатор `g` используется для выполнения глобального сопоставления (найти все совпадения, а не останавливаться после первого). Например, регулярное выражение `/.(at)/g` означает любой символ кроме символа новой строки, следом строчная `a`, далее строчная `t`. Из-за использования флага `g` в конце регулярного выражения, теперь оно найдет все совпадения во входной строке, а не остановится на первом (что является поведением по умолчанию).
```regex
"/.(at)/" => The fat cat sat on the mat.

"/.(at)/g" => The fat cat sat on the mat.
```
#### Multiline
Модификатор `m` используется для многострочного поиска. Как мы обсуждали ранее, якоря `(^, $)` используются для проверки, является ли шаблон началом или концом входной строки. Но если мы хотим, чтобы якоря работали в каждой строке, мы используем флаг `m`. Например, регулярное выражение `/at(.)?$/gm` означает строчную `a`, следом строчная `t` и любой символ кроме начала новой строки, идущий опционально (не обязательно). Из-за флага `m` механизм регулярных выражений будет искать данный шаблон в конце каждой строки в тексте.
```regex
"/.at(.)?$/" => The fat
                cat sat
                on the mat.

"/.at(.)?$/gm" => The fat
                  cat sat
                  on the mat.
```
***
### Greedy vs Lazy Matching
По умолчанию регулярное выражение выполняет жадное сопоставление, то есть оно будет искать совпадения как можно дольше. Мы можем использовать `?` для ленивого поиска, который будет стремиться быть как можно более коротким по времени.
```regex
"/(.*at)/" => The fat cat sat on the mat. 

"/(.*?at)/" => The fat cat sat on the mat. 
```
***
