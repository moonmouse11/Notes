# PEP 8
***
## Basic
Этот документ описывает соглашение о том, как писать код для языка `Python`, включая стандартную библиотеку, входящую в состав `Python`.
Этот документ и `PEP 257` (`Docstring Conventions`) были адаптированы из оригинальных рекомендаций Гвидо ван Россума "Руководство по стилю Python", с некоторыми дополнениями из руководства по стилю Барри.
Многие проекты имеют свои собственные руководства по стилю кодирования. В случае возникновения каких-либо противоречий, такие руководства имеют приоритет для конкретного проекта.
Ключевая идея Гвидо такова: код читается намного больше раз, чем пишется. Приведенные здесь рекомендации призваны улучшить читабельность кода и сделать его единообразным в широком спектре кода Python. Как говорится в `PEP 20`, "Читабельность имеет значение". В идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть.
Это руководство о согласованности и единстве. Согласованность с этим руководством очень важна. Согласованность внутри одного проекта еще важнее. А согласованность внутри модуля или функции — самое важное. Но важно помнить, что иногда это руководство неприменимо, и понимать, когда можно отойти от рекомендаций. Когда вы сомневаетесь, просто посмотрите на другие примеры и решите, какой выглядит лучше. И не стесняйтесь спрашивать!
В частности: не нарушайте обратную совместимость только для того, чтобы соответствовать этому PEP!
Веские причины для того, чтобы нарушить данные правила:
1. Применение правила сделает код менее читаемым даже для того, кто привык читать код, который следует этим правилам
2. Чтобы писать в едином стиле с кодом, который уже есть в проекте и который нарушает правила (возможно, в силу исторических причин) — впрочем, это возможность переписать чужой код
3. Код, о котором идет речь, появился до введения этого руководства, и нет других причин для его изменения
4. Код должен оставаться совместимым со старыми версиями Python, которые не поддерживают функцию, рекомендуемую руководством по стилю
***
## Code Lay-out
### Отступы
**Используйте 4 пробела на каждый уровень отступа.**
Продолжительные строки должны выравнивать обернутые элементы либо вертикально, используя неявную линию в скобках (круглых, квадратных или фигурных), либо с использованием висячего отступа. При использовании висячего отступа следует применять следующие соображения: на первой строке не должно быть аргументов, а остальные строки должны четко восприниматься как продолжение.
``` python
# Правильно
# Выровнено по открывающему разделителю
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Добавлено 4 пробела (следующий уровень отступа) для выделения аргумента от остальных
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# Неправильно
# Аргументы на первой строке запрещены, если не используется вертикальное выравнивание
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# Больше отступов требуется для выделения аргумента от остальных
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)

# Правило 4 пробелов опционально для строк-продолжений. Опционально:
# Висячие отступы *могут* быть отступом, отличным от 4 пробелов.
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)
```
Если условная часть if-выражения достаточно длинная и требует написания нескольких строк, стоит отметить, что комбинация из двух символов ключевого слова (т. е. if), плюс один пробел, плюс открывающая скобка создает естественный отступ из 4 пробелов для последующих строк многострочного условного выражения. Это может привести к визуальному конфликту с отступом набора кода, вложенного внутрь if-выражения, который также естественно будет отступать на 4 пробела. Данный PEP не занимает четкой позиции относительно того, как (и нужно ли) дополнительно визуально отличать такие условные строки от вложенного набора внутри if-выражения.
Приемлемые варианты в этой ситуации включают, но не ограничиваются следующими примерами:
``` python
# Без дополнительных отступов
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Добавьте комментарий, который обеспечит некоторое разграничение в редакторах, поддерживающих подсветку синтаксиса
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Добавьте несколько дополнительных отступов в строке продолжении
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
```
Закрывающие круглые/квадратные/фигурные скобки в многострочных конструкциях могут находиться под первым непробельным символом последней строки списка, например:
``` python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```
либо быть под первым символом строки, начинающей многострочную конструкцию:
``` python
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```
### Табуляция или пробелы
**Пробелы** - самый предпочтительный метод отступов.
Табуляция должна использоваться только для поддержки кода, написанного с отступами с помощью табуляции.
Python запрещает смешивание табуляции и пробелов в отступах.
### Максимальная длина строки
**Ограничьте длину строки максимум 79 символами.**
Для более длинных блоков текста с меньшими структурными ограничениями (строки документации или комментарии), длину строки следует ограничить 72 символами.
Ограничение необходимой ширины окна редактора позволяет иметь несколько открытых файлов бок о бок, и хорошо работает при использовании инструментов анализа кода, которые предоставляют две версии в соседних столбцах.
Некоторые команды предпочитают большую длину строки. Для кода, поддерживающегося исключительно или преимущественно этой группой, в которой могут прийти к согласию по этому вопросу, нормально увеличение длины строки с 80 до 100 символов (фактически увеличивая максимальную длину до 99 символов), при условии, что комментарии и строки документации все еще будут 72 символа.
Стандартная библиотека Python консервативна и требует ограничения длины строки в 79 символов (а строк документации/комментариев в 72).
Предпочтительный способ переноса длинных строк является использование подразумеваемых продолжений строк Python внутри круглых, квадратных и фигурных скобок. Длинные строки могут быть разбиты на несколько строк, обернутые в скобки. Это предпочтительнее использования обратной косой черты для продолжения строки.
Обратная косая черта все еще может быть использована время от времени. Например, длинная конструкция with до Python версии 3.10 не может использовать неявные продолжения, так что обратная косая черта является приемлемой:
``` python
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```
Ещё один случай - assert.
### Должна ли строка переноситься до или после бинарного оператора?
На протяжении десятилетий рекомендовалось разрывать строку после бинарных операторов. Но это может ухудшить читабельность в двух отношениях: операторы обычно разбросаны по разным колонкам экрана, и каждый оператор перемещается от своего операнда на предыдущую строку. Глазу приходится проделывать дополнительную работу, чтобы определить, какие элементы складываются, а какие вычитаются:
``` python
# Неправильно
# Операторы находятся далеко от своих операндов
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
```
Чтобы решить эту проблему читабельности, математики и их издатели придерживаются противоположного соглашения. Дональд Кнут объясняет традиционное правило в своей серии "Компьютеры и набор текста": *"Хотя формулы внутри абзаца всегда обрываются после бинарных операций и отношений, отображаемые формулы всегда обрываются перед бинарными операциями"*.
Следование традициям математики обычно приводит к созданию более читабельного кода:
``` python
# Правильно
# Легко сопоставлять операторы с операндами
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```
В коде Python допускается перенос перед или после двоичного оператора, если это поведение согласовано на локальном уровне. Для нового кода рекомендуется использовать стиль Кнута.
### Пустые строки
