# Basics
***
**PHP** - интерпретируемый язык программирования.
***
## History
PHP - Personal Homepage.
PHP - Hypertext Preprocessor.
### Versions
- 1995 - PHP1.
- 1997 - PHP2.
- 1998 - PHP3.
- 2000 - PHP4.
- 2004 - PHP5.
- 2015 - PHP7.
- 2020 - PHP8.
Подробнее:
	[[Notes/PHP/Versions|Versions]]
***
## Keywords
- `__halt_compiler()`
- `abstract`
- `and`
- `array()`
- `as`
- `break`
- `callable`
- `case`
- `catch`
- `class`
- `clone`
- `const`
- `continue`
- `declare`
- `default`
- `die()`
- `do`
- `echo`
- `else`
- `elseif`
- `empty()`
- `enddeclare`
- `endfor`
- `endforeach`
- `endif`
- `endswitch`
- `endwhile`
- `eval()`
- `exit()`
- `extends`
- `final`
- `finally`
- `fn` (as of PHP 7.4)
- `for`
- `foreach`
- `function`
- `global`
- `goto`
- `if`
- `implements`
- `include`
- `include_once`
- `instanceof`
- `insteadof`
- `interface`
- `isset()`
- `list()`
- `match` (as of PHP 8.0)
- `namespace`
- `new`
- `or`
- `print`
- `private`
- `protected`
- `public`
- `readonly` (as of PHP 8.1.0) *
- `require`
- `require_once`
- `return`
- `static`
- `switch`
- `throw`
- `trait`
- `try`
- `unset()`
- `use`
- `var`
- `while`
- `xor`
- `yield`
- `yield from`
***
## Variables 

### Variables types
- **Integers**
- **Doubles**
- **NULL**
- **Strings**
- **Booleans**
- **Arrays**
- **Objects**
- **Resources**
***
## Functions theory
**Детерминированность** — это одно из фундаментальных свойств функций. Функция будет детерминированной, когда для одних и тех же входных аргументов она возвращает один и тот же результат. (Например, функция, которая переворачивает строку, — детерминированная)
**Чистая функция** - Когда функция детерминированная и не имеет побочных эффектов, ее называют чистой функцией. Такие функции:
1. Проще читать, отлаживать и тестировать
2. Не зависят от порядка, в котором они вызываются
3. Просто запустить параллельно
4. Чистые функции независимы от времени. Недетерминизм и побочные эффекты добавляют понятие времени. Если функция зависит от чего-то, что может случиться или нет, и меняет что-то за пределами своих границ, то она становится зависимой от времени.
***
## Operator Precedence
Приоритет выполнения операторов PHP. 
1. `clone new` - клонирование/создание нового объекта
2. `**` - возведение в степень.
3. `+ - ++ -- ~ (int) (float) (string) (array) (object) (bool) @` - арифметика, инкремент, приведение типов.
4. `instanceof` - оператор проверки типа объекта.
5. `!` - логическое отрицание.
6. `* / %` - арифметические операторы.
7. `+ - .` - арифметические операторы.
8. `<< >>` - побитовые операторы.
9. `.` - оператор конкатенации.
10. `< <= > >=` -  операторы логического сравнения нестрогие.
11. `== != === !== <> <=>` - операторы логического сравнения строгие. (с проверкой типов).
12. `&` - логическое И и ссылка.
13. `^` - исключающее ИЛИ.
14. `|` - логическое ИЛИ.
15. `&&` - логическое И сокращенное.
16. `||` - логическое ИЛИ сокращенное.
17. `??` - оператор сравнения с `null`.
18. `? :` - тернарный оператор.
19. `= += -= *= **= /= .= %= &= |= ^= <<= >>= ??=` - операторы присваивания.
20. `yield from` - оператор сохранения в массив.
21. `yield` - оператор сохранения в массив.
22. `print` - оператор вывода строки.
23. `and` - логическое И.
24. `xor` - логическое Исключающее ИЛИ.
25. `or` - логическое ИЛИ.
***
## Package Manager
**Composer** - станартный менеджер пакетов для PHP.
Подробнее:
	[[Composer Main]]
***
## Tools
**Rector** — это инструмент автоматического рефакторинга, одной из главных функций которого является перевод кода на новые версии PHP и популярных фреймворков. 
**PHPStan** -
**SonarLint** -
***
## Raw Notes
- Переменная является именованым блоком памяти и позволяет обращаться к этому блоку памяти по имени. Для создания переменной в PHP ей достаточно присвоить ззначение. Имя переменной начинается с символа `$`.
- У переменных нет типа, но есть тип у их значения, на которое ссылается перменная. Узнать тип значения, на которое ссылается переменная можно с помощью функции `gettype()`.
- Для явного преобразования типов испольуется функция `settype()` или указывают конечный тип переменной в круглых скобках перед ней. Так же в PHP существует автоматическое преобразование типов.
- Основные операции выполняются с помощью арифметических, логических, побитовых операторов и операторов сравнения. Для конкатенации строк используется оператор `.`.
- Оператор присваивания возвращает значение, которое совпадает со значением переменной (которой присваивается значение). Существуют сокращенные формы операций присваивания.
- Для считывания данных из консоли используется функция `fgets()`.
- Условный оператор `if` позволяет выполнять разные блоки команд, в зависимости от истинности или ложности условия. Условие указывается в круглых скобках после ключевого слова `if`, а затем указываются команды, выполняемые при истинности условия. Команды, выполняемые при ложном условии, размещаются в `else` блоке.
- Оператор цикла `while` позволяет многократно выполнять блок команд. Команды выполняются, пока истинно условие, указанное после ключевого слова `while`.
- Оператор `do-while` отличается от оператора `while` тем, что в этом операторе сначала выполняется блок команд, а затем проверяется условие.
- Инструкция `break` позволяет досрочно завершить выполнение оператора цикла. Инструкция `continue` используется для досрочного завершения текущей итерации цикла.
- Оператор `switch` позволяет выполнять разные блоки команд в зависимости от значения некоторого выражения. Он содержит `case` блоки с контрольными значениями. Если значение проверяемого выражения совпадает с контрольным значением, выполняются команды в соотвествующем `case`-блоке. Команды в необязательном блоке `default` выполняются, если совпадения не найдены.
- Иструкция `goto` позволяет переходить к месту в программе, отмеченному меткой. Метка, к которой выполняется переход, указывается после инструкции `goto`. Чтобы отметить меткой место в программе, указывается имя метки и двоеточие.
- В PHP 8 появился оператор выбора `match`. Он позволяет проверить значение некоторого выражения и, в зависимости от этого значения, возвращает результат. В определенном смысле оператор `match`, это симбиоз тернарного оператора и `switch`.
- Массив представляет собой набор значений, объединенных общим именем. Значения массива могут относиться к разным типам.
- Доступ к элементу массива выполняется по ключу или индексу. Ключи\индексы могут быть целочисленными или текстовыми.
- Для перебора содержимого массива можно использовать оператор цикла `foreach`. Он позволяет получать доступ к ключам и значениям элементов массива.
- Элементами массива могут быть массивы. В этом случае доступ к элементам внутренних массивов получают с помощью нескольких ключей.
- Функция представлявет собой именованый блок программного кода, который можно вызывать по имени. Начинается описание функции с ключевого слова `function`, после которого указываются (в круглых скобках) аргументы функции и блоке из фигурных скобок - команды, выполняемые при вызове функции.
- Функция может возвращать результат. Возвращаемое функцией значение указывается после инструкции `return`, которая завершает выполнение функции.
- Для функции в явном виде можно указывать тип аргументов и тип результата.
- По умолчанию аргументы в функции передаются по значению (создаются копии переменных, указанных аргументами функции). Для передачи аргументов по ссылке в описании функции перед именем соотвествующего аргумента размещается символ ссылки `&`.
- Аргументы могут иметь значения по умолчанию (указываются через оператор присваивания после имени аргумента в описании функции). Если при вызове функции значение для аргумента не указано, используется значение по умолчанию.
- Можно создавать функции с произвольным количеством аргументов. В этом случае весь набор аргументов отождествляеся с одним аргументом, перед которым в описании функции ставиться троеточие `...`. Обрабатывется такой аргумент как массив.
- Функции можно определять с использованием рекурсии, когда функция вызывает сама себя.
- Функция `eval()` позволяет выполнять кооманды, создержащиеся в тексте, переданном аргументом функции.
- Можно создавать ананоимные функции, которые не имеют названия. Ананоимную функцию присваивают в качестве значение переменной, после чего переменную можно вызвать так, как если бы это была функция.
- В PHP 8 при вызове функций аргументы можно передовать по имени. В таком случае в команде вызова функции указывается имя аргумента (без символа `$`) и через двоеточие - значение.
- Ссылки позволяют получить альтернативный доступ к переменным. В случае создания ссылки на пременную ей присваивается эта переменная, предваренная инструкцией `&`. В таком случае говорят о жесткой ссылке.
- При использовании мягкой ссылки некоторой переменной в качестве значения присваивается текст с названием другой пременной. Добавление второго символа `$` к названию первой переменной означает доступ к переменной, текст с именем которой присвоем первой переменной.
- Помимо переменных могут использоваться константы. Их знначение после первого присваивания изменить нельзя. Константы можно создавать с помощью функции `define()` или с использованием ключевого слова `const`. Символ `$` в названиях констант не используется.
- В функциях могут использоваться глобальные переменные. Это переменные, которые доступны и вне области видимости функции. В теле функции глобальные переменные объявляются с помощью инструкции `global`.
- В функции могут использоваться статические переменные. Статическая переменная создается и получает первоначальнае значение при первом вызове функции. После завершения работы функции статическая переменная из памяти не удаляется, и при следу3ющем вызове эта переменная используется снова.
- В некоторых случаях используется многострочный текст. Для этого переменной присваивается выражение `<<< [HEREDOC_VAR]`. Текст вводится без кавычек, в несколько строк. Заканчивается выражениие той же меткой и точкой с запятой `[HEREDOC_VAR];`. Это аналог текста в двойных кавычках. Если первое появление метки заключить в одинарные кавычки, получаем аналог текста, заключенного в одинарные кавычки.
- Для работы с файлами предназначена группа функций:
	- `fopen()` - используется для открытия файла. Принимает в аргументы полный путь к файлу и режим доступа.
	- `fclose()` -используется при завершении работы с файлом.
- Для испортирования содержимого файла в программу добавляется инструкции `require_once`, после которой указывается текст с названием импортируемого файла.
- Объекты создаются на основе классов и могут содержать поля и методы.
- Описание класса начинается с ключевого слова `class`, после которого указывается имя класса и в фигурных скобках описание класса.
- Поля и методы, описанные в классе, называются членами класса. Методы описываются как обычные функции. При описании полей значение полей можно не указывать.
- Для определения уровня доступа можно использовать ключевые слова (спецификаторы уровня доступа) __*Отсутствие спецификатора доступа означает, что поле является открытым `public`*__
	- `private` - закрытый член класса.
	- `protected` - защищенный член класса.
	- `public` - открытый член класса.
- Для создания объекта на основе класса используется инструкция `new`, после которой указывается название класса. Значение соотвествующего выражения является ссылка на созданный объект. Эта ссылка присваивается значением объектной переменной.
- При присваивании объектных переменных копия объекта не создается, а две переменные будут ссылаться на один и тот же объект. Для создания копии объекта в команде присваивания используется инстррукция `clone`.
- Конструктор является методом, который автоматически вызывается при создании объекта. Он назыввается `__construnct()` и может иметь аргументы.
- Деструктор является методом, который вызывается автоматически при удалении объекта из памяти. Называется `__destruct()` и не имеет аргументов.
- Класс может содержать статические поля и методы. Такие члены класса описываютс ключевым словом `static`. Статические члены класса не привязанны к конктретному объекту и существуют вне зависимости от того, создавались ли объекты соотвествующего класса.
- Для обращения к полям объекта используются иструкции `$object->field;`. При названии поля символ `$` не указывается. Метод вызывается `$object->method();`. Обращение в статическим членам класса выполняется в формате `Class::$field;` и `Class::method();`.
- Ключевое слово `$this` используется в теле класса как идентификатор объекта, из которого вызывается метод. Ключевое слово `self` в теле класса используется при обращении к статичеким полям и методам.
- Есть специальные методы, которые имеют особое назначение и вызываются автоматически. Названия этих методов начинаются с двойного подчеркивания. Среди таких методов можно выделить `__toString()`, `__call()`, `__get()`, `__set()`.
- Начиная с версии PHP 8, в конструкторе класса можно объединять описание аргументов и определение полей класса. В таком случае для аргумента указывается спецификатор уровня доступа, что приводит к автматическому созданию соотвествующего поля и присваиванию ему значения.
- Новые классы можно создавать на основе уже существующих. Этот механизм называется наследованием. Класс, на основе которого создается новый класс, называется родительским. Класс, который создается на основе родительского, называется дочерним. Все незакрытые поля и методы родительского класса наследуются в дочернем классе.
- В описании дочернего класса после имени класса указывается ключевое слово `extends` и имя родительского класса. Родительский класс может быть только один. При этом родительский класс может быть родительским для другого дочернего класса.
- Методы, унаследованные в дочернем классе, можно переопределить. В это случае в дочернем классе описывается новая версия унаследованного метода. Аргументы новой версии метода должны соотвествовать аргументам в исходной версии метода. Для обращения к версии метода из родительского класса используют ключевое слово `parent::` и название родительского метода.
- Чтобы запретить переопределение метода, в его описании используется ключевое слово `final`. Это же ключевое слово используется в случае, если нужно запретить наследование на основе класса.
- Закрытые члены класса не наследуются. Это означает, что в дочернем классе к таким членам напрямую обратиться нельзя. При этом к ним могут обращаться унаследованные открытые методы.
- Защищенные члены класса описываются со спецификатором доступа `protected`. Они как и закрытые члены класса, доступны только в коде класса, но в отличии от `private` наследуются.
- Методы и конструкторы являются виртуальными - версия метода определяется классом объекта, из которого вызывается метод.
- Абстрактный класс описывается с ключевым словом `abstract` и содержит абстрактные методы. Абстрактный метод не описывается, а только объявляется. В объявлении абстрактного метода также используется ключевое слово `abstract`. Помимо абстрактных методов, абстрактные классы могут содержать обычные методы и поля. Абстрактные классы используются для создания на их основе дочерних классов.
- Интерфейс напоминает "полноостью абстрактный" класс. В интерфейсе нет полей (только константы), а методы только обновляются. Описывается интерфейс ключевым словом `interface`. Если интерфейс реализуется в классе, то этот класс должен содержать описание каждого из методов, объявленных в интерфейсе. Для реализации интерфейса в классе в описании класа после его имени указывается ключевое слово `implements` и имя реализуемого интерфейса. Если в классе реализуется несколько иинтерфейсов, они перечисляются через запятую.
- Интерфейс может наследоваться от другого интерфейса. При это используется ключевое слово `extends`.
- Класс может одновременно наследовать другой класс и реализовывать несколько интерфейсов.
- Трейты содержат блоки программного кода, которые можно включать в описание класса. Трейт описывается с использованием ключевого слова `trait`. Для включение содержимого трейта в класс используется инструкция `use`, после которой через запятую перечисляются включаемые в класс трейты.
- Если в качестве аргумента функции указать имя интерфейса, то аргументом это функции можно будет передавать объект класса, реалзующего данный интерфейс. Если указать в качестве типа аргумента им класса (в том числе абстрактного), то аргументом можно будет передавать объект дочернего класса. Для проверки типа объекта или аргумента можно использовать инструкцию `instanceof`.
- Для создания пространства имен используется инструкция `namespace`, после которой указывается название пространства имен. Для включения прространства имен в программу импортируется соответсвующий файл. Обращение к утилитам из пространства имен с указанием имени пространства имен. Для создания псевдонимов используется инструкция `use`.
- Анонимный класс используется в случае, если на основе класса предполагается создавать всего один объект. При этом объектной переменной присваивается выражение, которое начинается ключевыми словами `new class`. После них в фигурных скобках следует фактически описание класса, на основе которого и создается объект.
- Для обработки исключений можно использоувать конструкцию `try-catch-finally`. Контролируемый код помещается в блок `try`. Если при выполнении этого кода генерируется исключение, оно может быть обработано в блоке `catch`. Код в необязательном блоке `finally` выполняется всегда.
- Можно использовать несколько блоков `catch`. Для каждого блока указывается класс исключения, которое обрабатывается данным блоком.
- Исключенния можно генерировать искуственно. Для этого используется инструкция `throw`, после которой указывается класс генерируемого исключения.
- Можно создавать пользовательские классы исключений. Эти классы наследуются от класса `Exception`. Встроенные классы исключений реализуют интерфейс `Throwable`.
- Конструкции `try-catch-finally` могут быть вложенными, а исключения могут гененрироваться повторно. В таком случае объект сгенерированного исключения используется несколько раз.
- Существуют специалььные функции и утилиты, которые позволяют устанавливать режим отслеживания ошибок. Среди них можно выделить оператор отключения ошибок `@`, функции `error_reporting()`, `set_exception_handler()`, `set_error_handler()`, `trigger_error()`.
- Итератором называют объект класса, реализующего интерфейс `Iterator`. Истераторы используются для эмуляции последовательностей. В частности, их используют в операторе цикла `foreach`.
- Если создать класс и реализовать в этом классе методы интерфейса `Iterator`, то объект такого класса можно использовать как итератор коллекции в операторе цикла `foreach`.
- Можно создавать функции, которые результатом возвращают объект генератор. Генератор - это объект класса `Generator`, реализующий интерфейс `Iterator`. Для внесения значения в список для гененрирования используется инструкция `yield`, после которой указывается соотвествующее значение.
- Для получения текущего значения итератора используется метод `current()`. Для перехода к следующему значению для гененрирования используют метод `next()`. Для перевода итератора в состояние для гененрирования первого значения используется метод `rewind()`. Узнать ключ гененрируемого элемента можно с помощью метода `key()`. Проверить готовоность итератора можно с помощью метода `valid()`.
- В HTML-документы можно добавлять PHP-код, который выделяется инструкциями `<?php` и `?>`. Такие блоки позволяют формировать в автоматическом режиме фрагменты HTML-кода и вставлять его в итоговый документ.
- Сценарии PHP можно испльзовать для обработки запросов, выполняющихся через адресную строку. Параметры, которые передаются в адресной строке, заносятся в массив `$_GET`. Название параметра является ключом элемента, а значение параметра является значением элемента.
- Сценарии PHP используются для обработки данных форм, которые отправляютсясерверу для обработки. Обычно отправка данных выполняется методом `POST` и параметры, которые получает сервер, содержаться в массиве `$_POST`. Значение атрибута элемента формы определяет ключ элемента в массиве. Значение атрибута элемента формы является значением соотвествующего элемента в массиве.
***
