# Basics & Docs
***
## Introduction & Terminal commands
- `git help --all` - выводит все команды Git.
- `git --version` - выводит версию.
- `git commit --message="Message"` - длинная форма коммита.
- `git commit --interactive` - интерактивный режим коммита.
- `git commit --amend` - исправление последнего коммита.
- `git commit --amend --author "[author_name <author_email>]"` - изменяет автора последнего коммита.
- `git commit --dry-run` - ???.
- `git commit --amend --date "[date]"` - изменяет дату последнего коммита.
- `git commit --all` - подготовит все файлы в индексе к коммиту.
	- `git checkout tagname` - обращение к тегу.
	- `git checkout -- tagname` - обращение к файлу с таким же именем.
- `git init [directory_name]` - инициализация репозитория.
- `git init --bare [project_name]` - создаст чистый репозиторий, без рабочей директории.
- `git add [files_name]` - добавление файла в индекс Git.
- `git add .` - добавление всех файлов в директории и поддиректории в репозиторий.
- `git add . --interactive` - интерактивный режим добавления файла в индекс.
- `git status` - показывает состояние индекса репозитория на данный момент.
- `git config -l` - выводит содержимое конфигурационного файла с полным названием переменных.
- `git config user.name "[user_name]"` - установка имени пользователя.
- `git config user.email "[user_email]"` - установка почты пользователя.
```config
# Можно установить через переменные окружения (не протестировано).
GIT_AUTHOR_NAME - имя пользователя.
GIT_AUTHOR_EMAIL - почта пользователя.
# Эти пременные перезапишут все параметры конфигурации.
```
- `git show` -  показывает подробный лог последнего коммита. 
- `git show [commit_hash]` - показывает подробный лог конкретного коммита. 
- `git show [branch]:[file_name]` - показывает файл в определенной ветке.
- `git show --all [commit_hash]` - показывает полный лог конкретного коммита.
- `git show-branch` - показывает краткую сводку последнего коммита для текущей ветки.
- `git show-branch --more=[number]` - показывает краткую сводку для конкретного числа коммитов в текущей ветке.
- `git show-branch --reflog` - выводит рефлог.
- `git show-branch -a` - покажет все локальные и удаленные ветки.
- `git show --pretty=fuller` - выводит дополнительную информацию о коммите.
- `git show-ref` - выводит информацию о ссылках локального репозитория.
- `git diff [file or commit_hash]` - показывает детальные изменения.
- `git diff --cached` - выводит все изменения, находящееся в индексе.
- `git diff --stat` - выводит изменения с краткой статистикой.
- `git diff -u [first_commit] [second_commit]` - выводит различия между двумя коммитами.
- `git diff --base` - команда выводит комбинированный набор изменений при слиянии веток.
- `git branch` - выводит все локальные ветки.
- `git branch --remote` - выводит все удаленные ветки.
- `git branch -a` - выводит все доступные ветки.
- `git branch -M` - переименовывает ветку.
- `git branch [new_branch_name] [start_commit]` - создание новой ветки с определенного коммита.
- `git branch -d [branch_name]` - удаляет ветку из репозитория.
- `git branch --set-upstream [local_branch_name] [remote_branch]` - создает локальную ветку в связке с удаленной.
- `git rm -f [files_name]` - удаляет файл из репозитория.
- `git rm --cached [files_name]` - удаляет файл из индекса.
- `git mv [file_name] [new_file_name]` - перемещает или переименовывает файл.
- `git clone` - клонирует репозиторий. 
- `git config` - команда для работы с конфигурационным файлом Git.
- `git config -l` - просмотр переменных конфигуратора Git.
- `git config --unset [config_variable]` - удаление переменной настройки Git.
- `git config --global alias.[alias_name] \ [full_command]` - установка псевдонима в Git.
- `git cat-file -p [hash_file]` - выводит содержимое файла по hash.
- `git rev-parse [not_full_hash]` - выводит полный hash файла по сокращенному значению.
- `git write-tree` - создает дерево из текущего индекса, возвращает его hash.
- `git ls-files` - выводит список всех файлов в дереве.
- `git ls-files -s` - выводит список всех файлов в дереве с hash именами BLOB.
- `git ls-files --stage` - полная форма команды выше.
- `git ls-files -u` - выводит файлы с конфликтом слияния.
- `git ls-remote` - выводит ссылки в удаленном репозитории.
- `git commit-tree` - добавляет текущее дерево в коммит.
- `git tag -m "[text_message]" [tag_name]` - создает аннотированный тэг.
- `git hash-object [file_name]` - выводит полный hash файлы по имени.
- `git checkout HEAD -- [file_name]` - восстанавливает удаленный из репозитория файл.
- `git checkout -m [branch]` - переносит локальные изменения в указанную ветку.
- `git checkout -b [new_branch_name] [start_commit]` - создание и переключение на новую ветку.
- `git log [file_name]` - выводит историю изменений с файлом.
- `git log --follow [file_name]` - выводит полную историю изменений с файлом, даже если файл был удален или перемещен.
- `git log [-number] --pretty=oneline [hash_commit]` - выводит историю определенного коммита в одну строку.
- `git log -S[part_file]` - Pickaxe. 
- `git log -p [branch]` - выводит историю коммитов в одной заданной ветке.
- `git log -p [remote_branch]..[local_branch]` - выводит разницу коммитов между удаленной и локальной ветками.
- `git log --graph` - выводит историю коммитов с визуализацией веток и слияний.
- `git fetch` - загружает изменения с удаленного репозитория без внесения изменений в текущий.
- `git log --merge --left-right -p [file_name]` - показывает разницу изменений между объединяемыми ветками.
- `git symbolic-ref` - команда для управления символическими ссылками.
- `git rev-list --all` - выводит hash всех коммитов. 
- `git bisect` - утилита для поиска и изоляции дефектного коммита.
- `git blame` - показывает ревизию и автора определенной строки в файле.
- `git check-ref-format` - проверка нейминга веток.
- `git checkout -m` - выход из слияния веток.
- `git checkout --track` - создает одноименную локальную ветку в связке с указанной удаленной.
- `git merge-base [original_branch] [new_branch]` - поиск фиксации, из которой создана новая ветка.
- `git reflog [branch]` - выводит историю изменений ссылок в репозитории (История перемещений).
- `git reflog show` - синоним команды выше.
- `git fsck` - команда-валидатор работы Git.
- `git merge [branch]` - выполняет слияние указанной ветку в текущую.
- `git merge --squash [branch]` - выполняет слияние с объединением коммитов.
- `git merge -s [strategy] [branch]` - выполняет слияние с заданной стратегией.
- `git cherry -v [branch]` - показывает разницу коммитов между ветками.
- `git reset [commit_hash]` - удаляет коммиты из ветки разработки до указанного.
- `git pull -s ours [project]` - запуск специального слияния ours.
- `git pull -s subtree [project]` - запуск специального слияния subtree.
- `git pull --rebase` - переносит изменения в локальный репозиторий с переносом локальных неопубликованных коммитов (`git rebase` вместо `git merge`).
- `git apply` -
- `git cherry-pick [hash_commit]` - используется для перемещения заданного коммита из одной ветки, в другу.
- `git revert [hash_commit]` - отменяет заданный коммит.
- `git rebase [ported_branch]` - используется для изменения последовательности фиксаций. Переносит коммиты из одной ветки в другую.
- `git rebase --onto [base_branch] [parent_commit] [ported_branch]` - перенос ветки с частью другой ветки.
- `git rebase --continue` - продолжает перенос коммитов, после разрешения конфликтов.
- `git rebase --skip` - пропускает коммит при переносе.
- `git rebase -i` - интерактивный режим `rebase`.
- `git rebase --preserve-merges` - перенос веток, с сохранением структуры.
- `git stash save [stash_name]` - сохранение индекса в stash.
- `git stash list` - просмотр всех изменений в stash.
- `git stash pop [stash_index]` - достает отложенные изменения из stash.
- `git stash apply [stash_index]` - достает заданный индекс из stash, но не удаляет его в stash.
- `git stash drop [stash_index]` - удаляет заданные изменения из stash.
- `git stash show -p [stash_index]` - показывает изменения файлов в заданном stash.
- `git stash branch [new_branch]` - переносит изменения из stash в новую указанную ветку.
- `git filter-branch` -
- `git clone [repository_url]` - клонирует удаленный репозиторий в рабочую директорию.
- `git clone --bare [repository_url]` - создаст чистый репозиторий. Без рабочей директории.
- `git remote add origin [repository_url]` - добавление ссылки удаленного репозитория в локальный.
- `git remote` - команда для управления удаленными репозиториями.
- `git remote update [remote_branch]` - обновление ссылок удаленных веток.
- `git remote show origin` - подробная информация о удаленных ветках.
- `git remote add [new_branch]` - добавляет новую ссылку на удаленный репозиторий.
- `git remote remove [remote_branch]` - удаляет указанную удаленную ветку.
- `git branch -d -r [remote_branch]` - удаляет указанную удаленную ветку.
- `git remote update --prune [deleted_branch]` - получение обновлений и удаление устаревших веток из удаленного репозитория.
- `git remote rename [old_branch_name] [new_branch_name]` - переименование удаленных веток.
- `git remote set-url origin [repository_url]` - установка ссылка на удаленный репозиторий.

***
## Basics
### Структура работы Git.
`.git` - скрытая директория в корне репозитория. Хранит в себе все рабочие данные.
_**Репозиторий**_ - база данных, содержащая всю необходимую информацию для управления историей и версиями проекта. Для эффективности использования памяти, Git может архивировать свои данные в `pack` файлы.
Две основные структуры репозитория:
1. _**Хранилище объектов**_ - содержит историю файлов, и остальную информацию о коммитах, ветках и тегах. Содержит 4 основных объекта:
	- _**BLOB (Binary Large Object)**_ - содержит данные файла в бинарном виде.  (Не содержит метаданные)
	- _**Tree (Деревья)**_ - информация директории. Содержит метаданные для всех файлов Может рекурсивно ссылаться на другие поддеревья. Используется для построения полной иерархии файлов и каталогов в репозитории.
	- _**Commits (Коммиты)**_ - хранят метаданные для каждого изменения. (Дата, автор, сообщение, ветка?). Каждая фиксация указывает на объект дерева. 
	- _**Tags (Тэги)**_ - назначает человекочитаетмое имя (замена alias) определенному объекту. (Обычно коммиту).  Тэги бывают двух видов:
		- **Легковесный** - ссылка на коммит.
		- **Аннотированный** - объект, содержащий сообщение и может содержать цифровую подпись GPG-ключа.  
1. _**Индекс**_ - временный и динамический двоичный файл, который описывает структуру всего репозитория в моменте его текущего состояния. 
### Ассоциативные имена.
Каждому объекту в хранилище Git присваивается hash (функция SHA1). По нему происходит индексация всех файлов в структуре. Любое изменение в файле - изменяет hash, новая версия будет индексироваться отдельно.
### Система отслеживания контента.
Git не отслеживает имена файлов и директорий, отслеживает содержимое файлов и индексирует их. 
Git сравнивает файлы по значению hash - если файлы с одинаковым содержанием, значения hash-функции будут идентичны. 
Храниться только один файл с определенным hash значением. (и используется один BLOB).
Git хранит каждую версию полного файла - а не разницу между ними. (поскольку в hash-функцию улетает полный файл - то и индексироваться должно его полное значение).
Git вычисляет историю как ряд изменении между BLOB, а не набор различий одного файла.
### Путь файлов в Git.
Внутри Git не основывается на именах файлов. Имена и структура файлов индексируются отдельно (Собственно как и в Linux). 
Директория в Linux - это файл. Он также попадает в hash по содержанию.
### Pack-файлы
Файл, который хранит в себе разницу между BLOB объектами. Вместо хранения различий одного файла, Git хранит различия между BLOB объектами. 
Создание pack-файлов происходит в Git автоматически.
### Структура директории `.git`
- `.git/objects` - директория для всех объектов Git. Хранит BLOB и их hash именами. Для эффективности файловой системы (что бы не хранить все BLOB в одном месте) первые два символа (первый байт) hash создают директорию. Пример - `6c/94c753df030954c0d7148d9803ad0d8a25c520`
- `.git/index` - файл для хранения индекса. 
- `.git/branches` - директория для хранения информации о ветках.
- `.git/refs` - директория для хранения информации о тегах и локальных-удаленных ссылках.
- `.git/refs/stash` - директория для хранения отложенной информации.
- `.git/COMMIT_EDITMSG` - файл с сообщением коммита.
- `.git/config` - файл конфигурации Git.
- `.git/HEAD` - файл с текущим значением параметра HEAD.
- `.git/description` -
- `.git/hooks` -
- `.git/info` - информация о исключаемых файлах.
- `.git/logs` -
***
## Indexes
Git классифицирует файлы на три группы:
- _**Отслеживаемые**_ - файл, который находится в репозитории и в индексе.
- _**Игнорируемые**_ - файлы, которые не учитываются индексом Git. Объявляются в отдельном файле. `.gitignore`
- _**Неотслеживаемые**_ - файл, который находится в репозитории но не индексируется и не помещен в список игнорируемых.
Перенести файл из неотслеживаемого в отслеживаемые можно командой `git add [file_name]`.
**Пустые директории Git не фиксирует.**
### .gitignore
Можно создать в любом месте в репозитории.
1. Пустые строки игнорируются, как и строки начинающиеся с `#`. Можно использовать как комментарий. **Символ `#` должен находиться в самом начале строки.**
2. Обычные имена файлов соответствуют файлу в любом каталоге с указанным именем.
3. Имя каталога отмечается с помощью `/`.
4. Шаблон может содержать маски оболочки (аналог регулярных выражений). `*` - может соответствовать  имени файла или каталога.
5. `!` - инвертирует смысл шаблона
#### _**Приоритет игнорирования:**_
- Шаблоны, определенные в командной строке.
- Шаблоны, прочитанные из файла `.gitignore` в том же каталоге.
- Шаблоны `.gitignore` из родительского каталога.
- Шаблоны из файла `.git/info/exclude`
- Шаблонные из файла, указанного переменной конфигурации `core` `excludefile`
***
## Commits
_**Commit**_ - используется для записи изменений в репозиторий.
_**Коммит это снимок индекса.**_ Помещается в хранилище объектов. Хранит в себе список измененных объектов.
Каждая фиксация в Git представляет единственный, атомарный набор изменений относительно предыдущего состояния. Независимо от числа директорий, файлов и их содержимого, которые изменяются фиксацией, или применяются все изменения, или ни одно.
### Идентификация фиксаций.
Ссылки:
- **HEAD** - всегда показывает на последнюю фиксацию.
- **ORIG_HEAD** - предыдущее состояние **HEAD** при слиянии.
- **FETCH_HEAD** - ссылка на фиксацию удаленного репозитория.
- **CHERRY_PICK_HEAD** - 
- **MERGE_HEAD** - ссылка не верхушку ветки, с которой только что сделано слияние.
- `^` - ссылка на предпоследнюю фиксацию.
- `^[number]` - ссылка на разные фиксации при слиянии.
- `~[number]` - ссылка для перемещения по фиксациям в определенной родительской ветке. (Без коммита слияния `^` и `~` работают идентично).
### История фиксаций.
Основная команда для просмотра истории `git log`.
- `git log` = `git log HEAD` - стандартный вызов команды. Показывает историю с последнего коммита.
- `git log [breanch]` - вывод истории одной ветки.
- `git log [commit]` - вывод истории с определенного коммита.
- `git log --pretty=short --abbrev=commit [first_commit] [second_commit]` - просмотр истории между двумя коммитами.
- `git log -[number] -p [hash_commit]` - выводит полную историю со всеми изменениями определенного количества коммитов. 
- `git log --pretty=short --stat` - выводит статистику изменений в файлах.
Для фиксации истории изменений Git использует DAG (Directed acyclic graph Направленный ациклический граф). 
У DAG графа в Git есть особенности.
- У обычных коммитов есть только один родитель - предыдущий коммит в истории.
- У исходного коммита нет родителей.
- У коммита слияния два и более родительских коммита.
- Коммиты у которых больше двух потомков - формируют новую ветку.
### Диапазоны фиксаций.
Диапазоны фиксаций можно указывать во многих командах Git. 
Пример `[first_commit]..[last_commit]`.
**При выборе диапазона включает последний коммит и исключает последний.**
**Если пропущено одно из значений в диапазоне, вместо него подставляется HEAD.**
### Поиск коммитов.
Поиск дефектного коммита осуществляется утилитой `git bisect`
**`git bisect` рекомендуется использовать в пустом каталоге после клонирования репозитория. Есть большая вероятность испортить файлы, что явно не рекомендуется в рабочем.**
(НУЖНО БОЛЬШЕ ПОРАБОТАТЬ С ЭТОЙ ШТУКОЙ).
Поиск по строке в файле осуществляется командой `git blame`
**Pickaxe** - `git log -S[small_part_file]`.
***
## Branches
_**Ветка**_ - фундаментальное понятие, означающее запуск отдельной линии разработки в проекте. 
Ветка позволяет вести одновременно разработку в нескольких направлениях, которые потенциально могут привести к разным версиям проекта.
1. Ветки часто представляют отдельные версии программы.
2. Ветка может представлять этап разработки.
3. Ветка может изолировать разработку одной функции или помочь в исследовании сложной ошибки.
4. Отдельная ветка может представлять работу отдельного программиста.
_**Ветка**_ - это динамический объект, который перемещается с каждой фиксацией.
Ветки работают с такой же иерархией, как и файлы Unix.
### Правила именования веток.
- Имя не может начинаться со знака `-`
- У каждой ветки должно быть уникальное имя.
- Не рекомендуется начинать с `.`
- Не может содержать две последовательные точки `..`
- Не может содержать пробел.
- Не может содержать спец. символы Git.
_**Слияние**_ - дополнение ветки. При слиянии контент одной или нескольких соединяется в целевой веткой. 
***
## Differences
_**Differences**_ - это компактная сводка различий между двумя элементами.
Простые сравнение файлов между фиксациями можно увидеть командой `git diff`.
Есть три основных источника для дерева, которые можно использовать в `git diff`
1. Любой файл в пределах графа коммита.
2. Локальный рабочий каталог.
3. Индекс Git.
- `git diff` - показывает разницу между рабочей директорией и индексом.
- `git diff [file_name]` - показывает отличие одного файла в индексе.
- `git diff [commit]` - выводит различия между рабочей директорией и указанным коммитом. (По умолчанию, если фиксация не задана - подставляется HEAD).
- `git diff --cached [commit]`|`git diff --staged [commit]` - показывает разницу между изменениями в индексе и заданным коммитом.
- `git diff [first_commit] [second_commit]` - показывает разницу между двумя заданными коммитами. Игнорирует индекс и рабочую директорию.
- `git diff --M [first_commit] [second_commit]` - обнаруживает переименования файлов.
- `git diff -w [first_commit] [second_commit]`- сравнивает файлы не считая пробелы.
- `git diff --stat [first_commit] [second_commit]` - выводит статистику по отличиям в файлах.
- `git diff --color [first_commit] [second_commit]` - добавляет цвета в вывод.
### Differences with diapasons.
Разница между `git diff` и `git log`:
- `git diff` - не беспокоиться об истории файлов и о ветках.
- `git log` - знает об изменениях в файле и о разделении веток.
- `git log` - работает с историей коммитов. 
- `git diff` - работает в двумя разными коммитами обособлено.
Команда `git diff` может работать с ограничениями пути.
- `git diff [first_commit] [second_commit] [directory_name]` - выведет в терминал различия в файлах, которые находятся в заданной директории.
- `git diff [first_commit] [second_commit] [file_name]` - выведет в терминал разницу для заданного файла.
- `git diff -S[needle_string] [commit]` - поиск изменений в файлах по заданной строке.
***
## Merges
### Preparing merges.
Во время обычного слияния Git создает новые версии файлов и помещает их в рабочую директорию.
_**Слияния веток лучше производить "чистым" способом - с пустым индексом. Но так же можно и провести "грязным" если изменения в файлах не пересекаются.**_
Основная команда для слияния веток `git merge [branch]`(Указанная в команде ветки сливается в текущую).
### Conflicts.
Слияние двух и более веток часто бывает конфликтным. Когда один файл в разных ветках изменен по разному.
**MERGE_HEAD** - указатель на ветку слияния.
- `git diff HEAD` = `git diff -ours`
- `git diff MERGE_HEAD` = `git diff --theirs`
- `git diff --base` - команда выводит комбинированный набор изменений.
_**Запуск `git diff` в проблемном файле покажет только те разделы, которые содержат конфликт. Git сокращает вывод, показывая только конфликтные изменения.**_
- `git log --merge --left-right -p [file_name]` - показывает разницу изменений между объединяемыми ветками.
#### Способы Git отслеживать конфликты:
1. `.git/MERGE_HEAD` - содержит hash коммита слияния. 
2. `.git/MERGE_MSG` - содержит сообщение коммита слияния.
3. В индексе находятся три копии конфликтного файла. 
4. Конфликтная версия файла не сохраняется в индексе, только в рабочей директории.
Переключаться между ветками при разрешении конфликтов можно командами `git checkout --ours` и `git checkout --theirs`. Команды работают аналогично применению их в `git diff` выше.
### Cancelling.
- `git reset --heard HEAD` - жесткая отмена операции слияния веток с удалением.
- `git checkout -m` - выход из слияния веток.
### Merging strategies.
1. **Вырожденные слияния** - делятся на два типа:
	1. **Актуальная ветка (Already up-to-date)** - когда все коммиты сливаемой ветки присутствуют в основной. Обычно возникает при повторном слиянии.
	2. **Перемотка вперед (Fast--forward)** - когда в сливаемой ветке присутствуют все коммиты основной ветки.
2. **Обычные слияния** - здесь типов больше:
	1. **Стратегия решения (resolve)** - воздействует только на две ветки, определяя местоположение общего предка. Сливает изменения от основы до HEAD веток.
	2. **Рекурсивная стратегия (recursive)** - подобна стратегии решения, но разработана для слияния больше двух веток. После слияния через основание двух веток, применяет тот же подход к следующей.
		- Составляется список все общих предков, начиная с самого свежего.
		- Берется текущий коммит самого первого предка.
		- Выполняется слияние текущего коммита со следующим предком. В результате получаем виртуальный коммит, который берем за текущий.
		- Выполняем пока не закончится список общих предков.
	1. **Стратегия осьминога (octopus)** - Многократно вызывает рекурсивную стратегию, для слияния большого количества веток. **Не может обработать конфликтные слияния**.
3. **Специальные слияния** 
	1. **Ours** - объединяет любое число веток, но фактически отбрасывает их изменения добавляя только родительские hash коммитов с других веток.
	2. **Subtree** - выполняет слияние в другую ветку, но все в той ветке объединяется в поддерево текущего дерева. (Git определяет его автоматически).
- `git merge -s resolve [branch]` - команда запускает слияние с стратегией "Решения".
- `git pull -s ours [project]` - запуск специального слияния ours.
- `git pull -s subtree [project]` - запуск специального слияния subtree.
### Merge driver.
Каждая из стратегий слияния использует базовый драйвер. 
Драйвер принимает имена трех временных файлов. (Общий предок, основная версия ветки, сливаемая версия ветки). Изменяет целевую версию что бы получить результат.
Драйвер text оставляет маркеры в файле.
Драйвер binary сохраняет целевую версию и помечает файл как конфликтный в индексе.
Драйвер union просто оставляет все строки из обоих версий.
***
## Changing commits.
### Commits changing basics
_**Историю коммитов можно изменить только до ее публикации.**_
- `git reset` - команда переводит репозиторий в рабочую директорию в известное состояние. Корректирует HEAD и обновляет индекс, что бы он соответствовал заданному коммиту.
Команда `git reset` имеет три основных опции.
- `git reset --soft [hash_commit]` - изменяет HEAD на заданный коммит, индекс остается без изменений.
- `git reset --mixed [hash_commit]` - изменяет HEAD на заданный коммит, индекс будет пустым, файлы останутся в рабочей директории.
- `git reset --hard [hash_commit]` - изменяет HEAD на заданный коммит, индекс и рабочая директория удаляются.
_**`git reset`  сохраняет исходное значение HEAD в ORIG_HEAD**_ 
#### `git cherry-pick`
- `git cherry-pick [hash_commit]`
Переносит коммит из одной ветки в другую. Так же может перенести и заданный диапазон коммитов.
#### `git revert`
- `git revert [hash_commit]` - команда отменяет заданный коммит.
_**Команда не удаляет коммит из истории репозитория, а создает новый, который отменяет все изменения заданного коммита.**_
### Изменение последнего коммита.
`git commit --amend`
Позволяет исправить последний коммит. (Возможны конфликты, если коммит уже опубликован).
Для изменения данных в файлах, сперва нужно внести новый контент в индекс - потом воспользоваться командой.
### Перебазирование коммитов.
- `git rebase` - используется для изменения последовательности фиксаций. 
_**Команда меняет hash коммитов - можно легко сломать историю.**_ 
Самый лучший способ работать с изменениями в интерактивном режиме `git rebase -i`
Интерактивный режим позволяет в одном файле написать всю логику изменения коммитов.
Основные команды:
- `pick` - берет коммит. Используется для указания при работе с другими коммитами. Определенный порядок меняет историю Git.
- `reward` - берет коммит, но редактирует сообщение коммита.
- `edit` - берет коммит, и останавливается для его изменения как команда `git commit --amend`.
- `squash` - объединяет коммит с предыдущим.
- `fixup` - аналогично `squash`. Но оставляет только одну строку в сообщении коммита.
- `exec` - выполняет команду в терминале.
- `break` - остановка выполнения `rebase`. Можно продолжить командой `git rebase --continue`.
- `drop` - удаляет коммит.
- `label` - 
- `reset` - 
- `merge` - создает merge commit (коммит слияния).
- `update-ref` - меняет hash ссылку коммита на заданную.
#### _**Важные моменты:**_
1. `git rebase` - перезаписывает коммиты, создавая новые.
2. Старые коммиты не будут доступны и будут утеряны.
3. При совместной разработке будут конфликты, которые нужно согласовать с другими пользователями.
***
## Stash & Reflog
### Stash
_**Stash**_ - механизм Git, позволяющий сохранить текущий рабочий процесс и загрузить его в нужный момент. Команда `git stash`.
- `git stash save [stash_name]` - сохранение индекса в stash.
- `git stash list` - просмотр всех изменений в stash.
- `git stash pop [index]` - достает отложенные изменения из stash.
Изменения хранятся в `.git/refs/stash`.
_**Достать изменения из stash можно только с чистым индексом**_
- `git stash apply` - достает индекс из stash, но не удаляет его в stash.
- `git stash drop` - удаляет изменения из stash.
- `git stash branch [new_branch]` - переносит изменения из stash в новую указанную ветку.
### Reflog
_**Reflog**_ - запись изменений в ветках в репозитории.
Reflog записывает сведения о следующих операциях:
- Клонирование.
- Помещение данных в удаленный репозиторий.
- Создание новых коммитов.
- Изменение или создание веток.
- Операции rebase.
- Операции сброса.
С помощью Reflog можно добраться до утерянных или недостижимых коммитов, которые не видны в `git log` и `git show-branch`.
История в Reflog храниться временно.
- 30 дней для недостижимых коммитов.
- 90 дней для доступных в истории.
По истечении этого срока Garbage collector удалит это записи.
Изменить эти данные можно в конфигурации.
```config
gc.reflogExpireUnreachable - для недостижимых коммитов.
gc.reflogExpire - для доступных.
```
- `git reflog delete` - удаление записей Reflog.
- `git reflog expire` - запуск сборщика мусора Git.
***
## Remote repositories
### Remote basics
_**Клон**_ - копия репозитория, содержит все объекты оригинального репозитория. 
- `git clone [repository_url]` - клонирует локально удаленный репозиторий.
_**Каждый клон - это независимый и автономный репозиторий, симметричный удаленному оригиналу.**_
- Разработчики работают автономно.
- Разработчики могут работать удаленно.
- Возможность удаленного версионирования проекта.
- `remote` - ссылка на удаленный репозиторий.
Данные между локальным и удаленным репозиториями передаются с помощью команд:
1. `git pull [branch]` - загружает данные в локальный репозиторий.
2. `git push [branch]` - загружает данные в удаленный репозиторий.
Что бы отслеживать данные из других репозиториев Git использует **Удаленные ветки отслеживания (remote-tracking branches).**
Удаленная ветка - это ветка, которая работает как прокси для определенной ветки в удаленном каталоге.
Репозиторий Git может быть:
- _**Чистый (bare)**_ - нет рабочей директории, и не может быть использован для разработки. Грубо говоря - это только директория `.git`. Служит эталоном для совместной разработки.
	`git clone --bare [repository_url]` - создаст чистый репозиторий. Без рабочей директории.
- _**Репозиторий разработки (development, nonbare)**_ - используется по умолчанию.Обслуживает текущую ветку и рабочую директорию.
_**Git reflog выключен в чистых (bare) репозиториях.**_
При использовании `git clone` по умолчанию, локальные ветки исходного репозитория становятся удаленными ветками отслеживания в новом склонированном репозитории.
`.git/refs/remotes` - место хранения remote-tracking branches.
_**Не клонируются hooks, stash, reflog, config**_
Команды для работы с удаленным репозиторием:
- `git fetch [remote_branch]` - получает объекты из удаленного репозитория.
- `git pull [remote_branch]` - получает и объединяет (merge) объекты из удаленного репозитория.
- `git push [remote_branch]` - отправляет объекты в указанную ветку в удаленный репозиторий.
- `git ls-remotes` - показывает список ссылок в удаленном репозитории.
### Remote links
Удаленная ветка в файле конфигурации состоит из двух компонентов:
- **URL (Uniform resource locators)** - имя репозитория.
- **Refspec** - определяет отображение пространства имен между репозиториями.
**Git связывается с удаленными репозиториями в сети через Git native protocol (Порт 9418)**
Git-daemon использует это публикации репозиториев для чтения.
Для безопасности есть поддержка подключения по SSH.
Так же доступны подключения по HTTP, HTTPS, RSYNC.
### Refspec
Refspec ссылки используются командами `git fetch` `git push`.
Соответствие локальный ссылок репозитория с удаленными.
`git remote` - команда для управления удаленными репозиториями.
`git remote add origin [repository_url]` - добавление ссылки удаленного репозитория в локальный.
### Remote config
Git поддерживает три способа настройки и поддержания репозитория:
1. `git remote` - команда для работы с удаленным репозиторием.
2. `git config` - команда для работы с конфигурационным файлом Git.
3. `.git/config` - конфигурационный файл в директории.
- `git config remote.[remote_branch_name].url '[remote_branch_url]'` - добавляет ссылку на  новую удаленную ветку в репозиторий.
- `git config remote.[remote_branch_name].push [refspec_links]` - отправляет ссылку в удаленный репозиторий.
С помощью команды `git remote add [remote_branch_url]` можно добавить несколько удаленных репозиториев.

***
## Gitflow
